# 服务端加密接口改造说明

## 概述

本文档说明如何在云函数服务端实现 AES-256-GCM 加解密，与客户端配合完成加密通信。

## 加密规范

| 项目 | 规格 |
|------|------|
| 算法 | AES-256-GCM |
| 密钥长度 | 32 字节（256 位） |
| Nonce 长度 | 12 字节 |
| AuthTag 长度 | 16 字节 |
| 编码方式 | Base64 |

## 密文结构

```
Base64( Nonce[12字节] + Ciphertext[可变] + AuthTag[16字节] )
```

## 请求/响应格式

### 加密请求

```json
{
  "encrypted_body": "Base64编码的密文"
}
```

### 加密响应

```json
{
  "encrypted_body": "Base64编码的密文"
}
```

## Node.js 实现代码

### 1. 加密工具模块 (`crypto-utils.js`)

```javascript
/**
 * AES-256-GCM 加解密工具
 * 用于云函数服务端
 */
const crypto = require('crypto')

// 共享密钥（32字节 = 256位）
// 重要：客户端和服务端必须使用相同的密钥！
const ENCRYPTION_KEY = Buffer.from('your-32-byte-secret-key-here!!!!', 'utf8')
// 或者使用十六进制格式：
// const ENCRYPTION_KEY = Buffer.from('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef', 'hex')

const NONCE_LENGTH = 12  // GCM 推荐 12 字节
const AUTH_TAG_LENGTH = 16  // GCM 认证标签 16 字节

/**
 * AES-256-GCM 加密
 * @param {string} plaintext - 明文字符串
 * @returns {string} Base64 编码的密文（Nonce + Ciphertext + AuthTag）
 */
function encrypt(plaintext) {
  // 生成随机 Nonce
  const nonce = crypto.randomBytes(NONCE_LENGTH)
  
  // 创建加密器
  const cipher = crypto.createCipheriv('aes-256-gcm', ENCRYPTION_KEY, nonce)
  
  // 加密
  const encrypted = Buffer.concat([
    cipher.update(plaintext, 'utf8'),
    cipher.final()
  ])
  
  // 获取认证标签
  const authTag = cipher.getAuthTag()
  
  // 组合：Nonce + Ciphertext + AuthTag
  const combined = Buffer.concat([nonce, encrypted, authTag])
  
  // Base64 编码
  return combined.toString('base64')
}

/**
 * AES-256-GCM 解密
 * @param {string} ciphertextB64 - Base64 编码的密文
 * @returns {string} 解密后的明文
 * @throws {Error} 解密失败时抛出错误
 */
function decrypt(ciphertextB64) {
  // Base64 解码
  const combined = Buffer.from(ciphertextB64, 'base64')
  
  // 检查长度
  const minLength = NONCE_LENGTH + AUTH_TAG_LENGTH
  if (combined.length < minLength) {
    throw new Error('密文格式错误：长度不足')
  }
  
  // 提取各部分
  const nonce = combined.subarray(0, NONCE_LENGTH)
  const authTag = combined.subarray(combined.length - AUTH_TAG_LENGTH)
  const ciphertext = combined.subarray(NONCE_LENGTH, combined.length - AUTH_TAG_LENGTH)
  
  // 创建解密器
  const decipher = crypto.createDecipheriv('aes-256-gcm', ENCRYPTION_KEY, nonce)
  decipher.setAuthTag(authTag)
  
  // 解密
  try {
    const decrypted = Buffer.concat([
      decipher.update(ciphertext),
      decipher.final()
    ])
    return decrypted.toString('utf8')
  } catch (err) {
    throw new Error('解密失败：数据可能被篡改')
  }
}

/**
 * 解密请求体
 * @param {object} event - 云函数请求事件
 * @returns {object} 解密后的请求参数
 */
function decryptRequest(event) {
  if (!event.encrypted_body) {
    // 兼容未加密请求（可选，正式环境建议移除）
    return event
  }
  
  const plaintext = decrypt(event.encrypted_body)
  return JSON.parse(plaintext)
}

/**
 * 加密响应体
 * @param {object} response - 原始响应对象
 * @returns {object} 加密后的响应
 */
function encryptResponse(response) {
  const plaintext = JSON.stringify(response)
  return {
    encrypted_body: encrypt(plaintext)
  }
}

module.exports = {
  encrypt,
  decrypt,
  decryptRequest,
  encryptResponse,
  ENCRYPTION_KEY
}
```

### 2. 云函数改造示例

```javascript
/**
 * 卡密校验云函数（加密版）
 */
const { decryptRequest, encryptResponse } = require('./crypto-utils')

exports.main = async (event, context) => {
  try {
    // 1. 解密请求
    const params = decryptRequest(event)
    
    // 2. 原有业务逻辑
    const { key, product_id, machineCode, id } = params
    
    // ... 卡密校验逻辑 ...
    
    const result = {
      code: 0,
      msg: '校验成功',
      data: {
        card_id: 'xxx',
        expire_time: 1234567890,
        // ... 其他字段
      }
    }
    
    // 3. 加密响应
    return encryptResponse(result)
    
  } catch (err) {
    // 错误响应也需要加密
    return encryptResponse({
      code: -1,
      msg: err.message || '服务器错误'
    })
  }
}
```

### 3. uniCloud 云函数完整示例

```javascript
/**
 * router/admin/card/pub/verify.js
 * 加密版卡密校验接口
 */
'use strict'

const crypto = require('crypto')
const db = uniCloud.database()

// 加密配置
const ENCRYPTION_KEY = Buffer.from('your-32-byte-secret-key-here!!!!', 'utf8')
const NONCE_LENGTH = 12
const AUTH_TAG_LENGTH = 16

// 解密函数
function decrypt(ciphertextB64) {
  const combined = Buffer.from(ciphertextB64, 'base64')
  if (combined.length < NONCE_LENGTH + AUTH_TAG_LENGTH) {
    throw new Error('密文格式错误')
  }
  
  const nonce = combined.subarray(0, NONCE_LENGTH)
  const authTag = combined.subarray(combined.length - AUTH_TAG_LENGTH)
  const ciphertext = combined.subarray(NONCE_LENGTH, combined.length - AUTH_TAG_LENGTH)
  
  const decipher = crypto.createDecipheriv('aes-256-gcm', ENCRYPTION_KEY, nonce)
  decipher.setAuthTag(authTag)
  
  const decrypted = Buffer.concat([
    decipher.update(ciphertext),
    decipher.final()
  ])
  return decrypted.toString('utf8')
}

// 加密函数
function encrypt(plaintext) {
  const nonce = crypto.randomBytes(NONCE_LENGTH)
  const cipher = crypto.createCipheriv('aes-256-gcm', ENCRYPTION_KEY, nonce)
  
  const encrypted = Buffer.concat([
    cipher.update(plaintext, 'utf8'),
    cipher.final()
  ])
  
  const authTag = cipher.getAuthTag()
  const combined = Buffer.concat([nonce, encrypted, authTag])
  
  return combined.toString('base64')
}

// 加密响应
function encryptResponse(data) {
  return { encrypted_body: encrypt(JSON.stringify(data)) }
}

module.exports = async (event) => {
  try {
    // 解密请求
    let params = event
    if (event.encrypted_body) {
      params = JSON.parse(decrypt(event.encrypted_body))
    }
    
    const { key, product_id, machineCode, id } = params
    
    // 参数校验
    if (!key) {
      return encryptResponse({ code: -1, msg: '请输入密钥' })
    }
    if (!id) {
      return encryptResponse({ code: -1, msg: '请传入用户ID参数（id）' })
    }
    
    // 查询卡密
    const cardRes = await db.collection('cards')
      .where({ card_code: key, product_id })
      .get()
    
    if (cardRes.data.length === 0) {
      return encryptResponse({ code: -1, msg: '卡密不存在或不属于该产品' })
    }
    
    const card = cardRes.data[0]
    
    // 验证用户
    if (card.user_id !== id) {
      return encryptResponse({ code: -1, msg: '此卡密不属于您，无法使用' })
    }
    
    // 检查过期
    if (card.expire_time && card.expire_time < Date.now()) {
      return encryptResponse({ code: -1, msg: '卡密已过期' })
    }
    
    // ... 其他业务逻辑（机器码绑定等）...
    
    // 返回成功响应
    return encryptResponse({
      code: 0,
      msg: '校验成功',
      data: {
        card_id: card._id,
        card_code: card.card_code,
        product_id: card.product_id,
        product_name: card.product_name,
        expire_time: card.expire_time,
        expire_time_text: card.expire_time_text,
        // ... 其他字段
      }
    })
    
  } catch (err) {
    console.error('卡密校验错误:', err)
    return encryptResponse({
      code: -1,
      msg: err.message || '服务器错误'
    })
  }
}
```

## 密钥管理

### 生成安全密钥

```javascript
// 生成随机 32 字节密钥
const crypto = require('crypto')
const key = crypto.randomBytes(32)
console.log('Hex 格式:', key.toString('hex'))
console.log('Base64 格式:', key.toString('base64'))
```

### 密钥存储建议

| 环境 | 存储方式 |
|------|----------|
| 开发环境 | 硬编码在代码中（仅开发用） |
| 生产环境 | 环境变量或密钥管理服务 |
| 客户端 | 编译到 Rust 二进制文件中 |

### 环境变量方式

```javascript
// 从环境变量读取密钥
const ENCRYPTION_KEY = Buffer.from(process.env.ENCRYPTION_KEY, 'hex')
```

## 兼容性处理

如果需要同时支持加密和非加密请求（过渡期）：

```javascript
function decryptRequest(event) {
  // 检查是否为加密请求
  if (event.encrypted_body) {
    const plaintext = decrypt(event.encrypted_body)
    return JSON.parse(plaintext)
  }
  // 非加密请求直接返回（过渡期兼容）
  return event
}
```

## 测试验证

### 加解密测试

```javascript
// 测试代码
const { encrypt, decrypt } = require('./crypto-utils')

const original = JSON.stringify({
  key: 'ABCD-1234-EFGH-5678',
  product_id: 'test-product',
  machineCode: 'machine-001',
  id: 'user123'
})

console.log('原文:', original)

const encrypted = encrypt(original)
console.log('密文:', encrypted)

const decrypted = decrypt(encrypted)
console.log('解密:', decrypted)

console.log('验证:', original === decrypted ? '✅ 通过' : '❌ 失败')
```

## 注意事项

1. **密钥一致性**：客户端和服务端必须使用完全相同的密钥
2. **密钥安全**：不要将密钥提交到代码仓库，使用环境变量或密钥管理服务
3. **错误处理**：解密失败时返回通用错误信息，避免泄露加密细节
4. **日志安全**：不要在日志中打印明文请求参数或密钥
5. **HTTPS**：加密是额外保护层，仍建议使用 HTTPS 传输

---

**最后更新：** 2025-12-13
