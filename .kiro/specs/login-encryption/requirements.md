# 需求文档

## 简介

本功能为卡密校验接口的请求和响应添加 AES-GCM 加密保护，防止明文传输被抓包窃取敏感信息（卡密、用户ID、机器码等）。加密在 Tauri Rust 后端实现，前端无感知。

## 术语表

- **AES-GCM**：高级加密标准-伽罗瓦/计数器模式，一种认证加密算法，同时提供机密性和完整性保护
- **Nonce**：一次性随机数，用于确保相同明文每次加密结果不同
- **密钥（Key）**：用于加解密的 256 位密钥，客户端和服务端共享
- **Base64**：一种将二进制数据编码为 ASCII 字符串的方式

## 需求

### 需求 1

**用户故事：** 作为开发者，我希望登录请求参数被加密传输，以防止卡密和用户信息被抓包窃取。

#### 验收标准

1. WHEN 客户端发送登录请求 THEN 系统 SHALL 使用 AES-256-GCM 算法加密请求体
2. WHEN 加密请求体 THEN 系统 SHALL 生成 12 字节随机 Nonce 并附加到密文前
3. WHEN 构造加密请求 THEN 系统 SHALL 将 Nonce + 密文 + AuthTag 组合后进行 Base64 编码
4. WHEN 发送加密请求 THEN 系统 SHALL 使用 `encrypted_body` 字段包装加密数据

### 需求 2

**用户故事：** 作为开发者，我希望服务端返回的授权信息也被加密，以防止响应数据被窃取。

#### 验收标准

1. WHEN 接收到加密响应 THEN 系统 SHALL 对 Base64 编码的响应体进行解码
2. WHEN 解码响应体 THEN 系统 SHALL 提取 Nonce（前 12 字节）和密文（剩余部分）
3. WHEN 解密响应体 THEN 系统 SHALL 使用相同的 AES-256-GCM 密钥进行解密
4. WHEN 解密成功 THEN 系统 SHALL 返回原始 JSON 响应数据

### 需求 3

**用户故事：** 作为开发者，我希望加密模块提供清晰的错误处理，以便排查加解密问题。

#### 验收标准

1. IF 密钥长度不是 32 字节 THEN 系统 SHALL 返回明确的密钥长度错误
2. IF Base64 解码失败 THEN 系统 SHALL 返回解码错误信息
3. IF 密文长度不足（小于 Nonce 长度） THEN 系统 SHALL 返回数据格式错误
4. IF AES-GCM 解密失败（认证标签不匹配） THEN 系统 SHALL 返回解密失败错误

### 需求 4

**用户故事：** 作为开发者，我希望加密功能对前端透明，无需修改前端代码。

#### 验收标准

1. WHEN 前端调用登录接口 THEN 系统 SHALL 在 Rust 后端自动完成加解密
2. WHEN 加解密完成 THEN 系统 SHALL 返回与原接口相同格式的响应数据
3. WHEN 加密功能启用 THEN 系统 SHALL 保持现有 `http_post` 命令的调用方式不变

### 需求 5

**用户故事：** 作为开发者，我希望加密密钥安全存储，不被轻易提取。

#### 验收标准

1. WHEN 存储加密密钥 THEN 系统 SHALL 将密钥硬编码在 Rust 二进制文件中
2. WHEN 编译发布版本 THEN 系统 SHALL 确保密钥不以明文形式出现在配置文件中
